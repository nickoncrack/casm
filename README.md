# casm
A cpu emulator that works on a homemade instruction set

## How it works
### 1. Registers
The available registers are:
+ `a, b, c, d`, which are the standard 16-bit registers
+ `r0`, a special register, the use of which will be explained in section `2a`
+ `ip, sp`, instruction pointer and stack pointer respectively, which are inaccessible using the assembly

### 2. Assembler
+ The assembler parses the code line by line
+ If a symbolic reference is found, i.e. a function (`func`), an operation between symbols and registers (`func+a+6`), the assembler will call `__sym_ref()`
+ `__sym_ref()` will simplify the symbolic reference by replacing the value corresponding to the symbol or by splitting the operation into multiple instructions if a register is involved<br>

#### 2a. Symbolic reference parsing
```asm
func:
    does something

main:
    mov a, 12
    jmp func+a+6
```

The instruction `jmp func+a+6` is converted to:

```asm
mov r0, a
add r0, func+6
jmp r0
```
where `r0` is a special register that is used in this kind of operations. It can be used by the programmer as a general purpose register but this kind of use is non-standard.

Since a register isn't a compile time constant, meaning we can't find it's value during assembly we have to do this *expansion*. On the other hand, `func+6` ___is___ a compile time constant so we can calculate it's value in the assembly process and replace it.
<br>

#### 2b. Stages of the assembly
Suppose we have the following program (which is unnecessarily *complicated* for the sake of explaining the inner workings of the assembler):

```asm
entry 0x1000

end:
    dump
    end

loop:
    end ; this is never executed since we jump to loop+6, it's just a placeholder for testing addition between symbols and integers
    add a, 1
    cmp a, 10
    je end
    jl loop+6

main:
    mov a, 0
    mov b, 6 ; the instruction size is fixed to 6 bytes
    jmp loop+b
```

The assembler will first convert it to:

```asm
jmp 0x1030
dump
end
end
add a, 1
cmp a, 10
je 0x1006
jl 0x1018
mov a, 0
mov b, 6
mov r0, b
add r0, 0x1012
jmp r0
```

This snippet, although it's assembly, it isn't easily readable since the symbols have been replaced with their corresponding addresses and inline operations have been expanded into multiple instructions. This *first stage* of the assembly is internal and not outputted by the assembler, however, these instructions are ready to be directly converted into machine code, which is the second (and final) stage of the assembly.
<br>

#### 2c. Machine code
Using the following table I will explain how the machine code is generated by splitting an instruction into 3 parts:

1. The instruction prefix
2. The opcode
3. The instruction operands

```asm
addr     pre  op   operand 1 operand 2    <sym+i>     instruction
0x1000 | 0xFF 0x11 0x10 0x30 0x00 0x00                jmp <main+0>
0x1006 | 0x00 0xFE 0x00 0x00 0x00 0x00    <end+0>     dump
0x100C | 0x00 0xFF 0x00 0x00 0x00 0x00    <end+1>     end
0x1012 | 0x00 0xFF 0x00 0x00 0x00 0x00    <loop+0>    end
0x1018 | 0xFF 0x02 0x00 0x00 0x00 0x01    <loop+1>    add a, 1
0x101E | 0xFF 0x04 0x00 0x00 0x00 0x0A    <loop+2>    cmp a, 10
0x1024 | 0xFF 0x07 0x10 0x06 0x00 0x00    <loop+3>    je <end+0>
0x102A | 0xFF 0x0B 0x10 0x18 0x00 0x00    <loop+4>    jl <loop+1>
0x1030 | 0xFF 0x03 0x00 0x00 0x00 0x00    <main+0>    mov a, 0
0x1036 | 0xFF 0x03 0x01 0x00 0x00 0x06    <main+1>    mov b, 6
0x103C | 0x00 0x03 0x04 0x00 0x01 0x00    <main+2>    mov r0, b
0x1042 | 0xFF 0x02 0x04 0x00 0x10 0x02    <main+3>    add r0, <loop+0>
0x1048 | 0x00 0x11 0x04 0x00 0x00 0x00    <main+4>    jmp r0
```
<sub>Note: Here `<sym+i>` represents the *i*th instruction, unlike symbolic addition (`func+6`) which respresents bytes.</sub>

1. The instruction prefix is a single byte that is placed *before* the opcode and is used to give information to the processor about the operands of the current instruction. (corresponds to the `pre` column)
+ The prefix `0xFF` or `PRE_IMM` is used to tell the processor that an immediate value (i.e. an integer) is passed in the instruction. In 2-operand instructions (like `mov`), the prefix is referring to the second operand, since the first operand can't be anything other than a register. This is currently the *only* available instruction prefix.
+ If the prefix is unset (`0x00`), the processor expects a register in the first/second operand, depending on the instruction.
2. The opcode, which is the second byte in an instruction, tells the processor which instruction we want to execute. The opcode list can be found in `instructions.h`
3. The operands occupy the rest of the available bytes in our 6 byte instruction with each operand occupying 2 bytes. Each operand can either contain a register or an immediate value (as explained above). If an operand contains a register, then its *high* (first) byte will contain a number which corresponds to the register. The numbers corresponding to each register can be found in `instructions.h`. If an operand contains an immediate value, the instruction prefix will be set to `0xFF` and the value will be stored in the operand's bytes in big-endian order.
<br>
Now let's talk about the first instruction.

Notice how the instruction at address `0x1000` which is `jmp <main+0>` (or `jmp 0x1030` if you like) doesn't exist in the initial program? This is used to simplify the assembly process. The instruction `entry 0x1000` doesn't *really* set the entry point (beginning of `main`) to `0x1000`, instead, it tells the assembler that the entire program will be placed at that address. Since the code is parsed line by line, it means that if the main function is first, it can't make any symbol references, as almost all other symbols will be defined after the main function. Therefore, once the assembly is completed, the assembler finds the address of the first instruction of `main` and places a jump instruction to that address at the top of the program.
