# casm
A cpu emulator that works on a homemade instruction set

## How it works
### 1. Registers
The available registers are:
+ `a, b, c, d`, which are the standard 16-bit registers
+ `r0`, a special register, the use of which will be explained in section `2a`
+ `ip, sp`, instruction pointer and stack pointer respectively, which are inaccessible using the assembly
+ `flags`, contains various flags about the current instruction, can be modified using `setf`
<br>

As explained below, registers are passed as numbers in the high byte of an operand.
The following table contains the number corresponding to each register
| Register | Value |
| --- | --- |
| Register A | 0x00 |
| Register B | 0x01 |
| Register C | 0x02 |
| Register D | 0x03 |
| Register `r0` | 0x04 |
### 2. Assembler
+ The assembler parses the code line by line
+ If a symbolic reference is found, i.e. a function (`func`), an operation between symbols and registers (`func+a+6`), the assembler will call `__sym_ref()`
+ `__sym_ref()` will simplify the symbolic reference by replacing the value corresponding to the symbol or by splitting the operation into multiple instructions if a register is involved<br>

#### 2a. Symbolic reference parsing
```asm
func:
    does something

main:
    mov a, 12
    jmp func+a+6
```

The instruction `jmp func+a+6` is converted to:

```asm
mov r0, a
add r0, func+6
jmp r0
```
where `r0` is a special register that is used in this kind of operations. It can be used by the programmer as a general purpose register but this kind of use is non-standard.

Since a register isn't a compile time constant, meaning we can't find it's value during assembly we have to do this *expansion*. On the other hand, `func+6` ___is___ a compile time constant so we can calculate it's value in the assembly process and replace it.
<br>

#### 2b. Stages of the assembly
Suppose we have the following program (which is unnecessarily *complicated* for the sake of explaining the inner workings of the assembler):

```asm
entry 0x1000

end:
    dump
    end

loop:
    end ; this is never executed since we jump to loop+6, it's just a placeholder for testing addition between symbols and integers
    add a, 1
    cmp a, 10
    je end
    jl loop+6

main:
    mov a, 0
    mov b, 6 ; the instruction size is fixed to 6 bytes
    jmp loop+b
```

The assembler will first convert it to:

```asm
jmp 0x1030
dump
end
end
add a, 1
cmp a, 10
je 0x1006
jl 0x1018
mov a, 0
mov b, 6
mov r0, b
add r0, 0x1012
jmp r0
```

This snippet, although it's assembly, it isn't easily readable since the symbols have been replaced with their corresponding addresses and inline operations have been expanded into multiple instructions. This *first stage* of the assembly is internal and not outputted by the assembler, however, these instructions are ready to be directly converted into machine code, which is the second (and final) stage of the assembly.
<br>

#### 2c. Machine code
Using the following table I will explain how the machine code is generated by splitting an instruction into 3 parts:

1. The instruction prefix
2. The opcode
3. The instruction operands

```asm
addr     pre  op   operand 1 operand 2    <sym+i>     instruction
0x1000 | 0xFF 0x11 0x10 0x30 0x00 0x00                jmp <main+0>
0x1006 | 0x00 0xFE 0x00 0x00 0x00 0x00    <end+0>     dump
0x100C | 0x00 0xFF 0x00 0x00 0x00 0x00    <end+1>     end
0x1012 | 0x00 0xFF 0x00 0x00 0x00 0x00    <loop+0>    end
0x1018 | 0xFF 0x02 0x00 0x00 0x00 0x01    <loop+1>    add a, 1
0x101E | 0xFF 0x04 0x00 0x00 0x00 0x0A    <loop+2>    cmp a, 10
0x1024 | 0xFF 0x07 0x10 0x06 0x00 0x00    <loop+3>    je <end+0>
0x102A | 0xFF 0x0B 0x10 0x18 0x00 0x00    <loop+4>    jl <loop+1>
0x1030 | 0xFF 0x03 0x00 0x00 0x00 0x00    <main+0>    mov a, 0
0x1036 | 0xFF 0x03 0x01 0x00 0x00 0x06    <main+1>    mov b, 6
0x103C | 0x00 0x03 0x04 0x00 0x01 0x00    <main+2>    mov r0, b
0x1042 | 0xFF 0x02 0x04 0x00 0x10 0x02    <main+3>    add r0, <loop+0>
0x1048 | 0x00 0x11 0x04 0x00 0x00 0x00    <main+4>    jmp r0
```
<sub>Note: Here `<sym+i>` represents the *i*th instruction, unlike symbolic addition (`func+6`) which respresents bytes.</sub>

1. The instruction prefix is a single byte that is placed *before* the opcode and is used to give information to the processor about the operands of the current instruction. (corresponds to the `pre` column)
+ The prefix `0xFF` or `PRE_IMM` is used to tell the processor that an immediate value (i.e. an integer) is passed in the instruction. In 2-operand instructions (like `mov`), the prefix is referring to the second operand, since the first operand can't be anything other than a register. This is currently the *only* available instruction prefix.
+ If the prefix is unset (`0x00`), the processor expects a register in the first/second operand, depending on the instruction.
2. The opcode, which is the second byte in an instruction, tells the processor which instruction we want to execute. The opcode list can be found in section `3a`
3. The operands occupy the rest of the available bytes in our 6 byte instruction with each operand occupying 2 bytes. Each operand can either contain a register or an immediate value (as explained above). If an operand contains a register, then its *high* (first) byte will contain a number which corresponds to the register. If an operand contains an immediate value, the instruction prefix will be set to `0xFF` and the value will be stored in the operand's bytes in big-endian order.
<br>
Now let's talk about the first instruction.

Notice how the instruction at address `0x1000` which is `jmp <main+0>` (or `jmp 0x1030` if you like) doesn't exist in the initial program? This is used to simplify the assembly process. The instruction `entry 0x1000` doesn't *really* set the entry point (beginning of `main`) to `0x1000`, instead, it tells the assembler that the entire program will be placed at that address. Since the code is parsed line by line, it means that if the main function is first, it can't make any symbol references, as almost all other symbols will be defined after the main function. Therefore, once the assembly is completed, the assembler finds the address of the first instruction of `main` and places a jump instruction to that address at the top of the program.
<br>

### 3. Instructions

#### 3a. Normal instructions
| Opcode | Mnemonic | Description |
| --- | --- | --- |
| 0x00 | NOP | No instruction |
| 0x01 | SETF | Modifies the `flags` register according to the operation: `flags \|= op1` |
| 0x02 | ADD | Addition between the 2 operands: `op1 += op2` |
| 0x03 | MOV | Moves the second operand to the first: `op1 <- op2` |
| 0x04 | CMP | Compares the first operand with the second and sets the `flags` register accordingly |
| 0x05 | JZ | Jumps to `op1` if the zero bit is set in `flags` |
| 0x06 | JNZ | Jumps to `op1` if the zero bit is __not__ set in `flags` |
| 0x07 | JE | Jumps to `op1` if the equal bit is set |
| 0x08 | JNE | Jumps to `op1` if the equal bit is __not__ set |
| 0x09 | JG | Jumps to `op1` if the greater bit is set |
| 0x0A | JGE | Jumps to `op1` if the greater or the equal bit is set |
| 0x0B | JL | Jumps to `op1` if none of the comparison bits are set |
| 0x0C | JLE | Jumps to `op1` if none of the comparison bits are set or if the equal bit is set |
| 0x0D | PUSH | Pushes `op1` to the stack |
| 0x0E | POP | Pops the last stack value into `op1`. `op1` __must__ be a register |
| 0x0F | CALL | Pushes the current `ip` into the stack and jumps to `op1` |
| 0x10 | RET | Jumps to the last value of the stack |
| 0x11 | JMP | Jumps to `op1` |
| 0x12 | LIDT | Loads an interrupt descriptor table from a given memory address |
| 0x13 | INT | Triggers an interrupt, even when interrupts are *disbaled* |
| 0x14 | CLI | Clear interrupt flag; disables the interrupts |
| 0x15 | STI | Set interrupt flag; enables the interrupts |
| 0x16 | SUB | Subtraction between the 2 operands: `op1 -= op2` |

#### 3b. Special instructions
| Opcode | Mnemonic | Description |
| --- | --- | --- |
| 0xFE | DUMP | Debug instruction; dumps the current state of the processor to the terminal |
| 0xFF | END | Marks the end of the program execution |
